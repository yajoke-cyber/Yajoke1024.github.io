<!DOCTYPE html>
<html lang="zh-CN">
  

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1.0, user-scalable=no">
  <meta name="theme-color" content="#202020"/>
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script>
  
  
    <meta name="keywords" content="nmd," />
  

  
    <meta name="description" content="JavaScript基础" />
  
  
  <link rel="icon" type="image/x-icon" href="/logo.png">
  <title>JavaScript基础 [ Yajoke的小站 ]</title>
  
    <!-- stylesheets list from config.yml -->
    
      <link rel="stylesheet" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css">
    
      <link rel="stylesheet" href="/css/xoxo.css">
    
  
<meta name="generator" content="Hexo 5.4.0"></head>


  <body>
    <div class="nav-container"><nav class="home-menu pure-menu pure-menu-horizontal">
  <a class="pure-menu-heading" href="/">
    <img class="avatar" src="https://s4.ax1x.com/2021/12/20/Tu8HPA.jpg" />
    <span class="title">Yajoke的小站</span>
  </a>

  <ul class="pure-menu-list clearfix">
     
    <li class="pure-menu-item">
      <a href="/" class="pure-menu-link">首页</a>
    </li>
      
    <li class="pure-menu-item">
      <a href="/archives" class="pure-menu-link">归档</a>
    </li>
      
    <li class="pure-menu-item">
      <a href="/tags" class="pure-menu-link">标签</a>
    </li>
     
  </ul>
</nav>
</div>

    <div class="container" id="content-outer">
      <div class="inner" id="content-inner"><div class="post-container">
  <article class="post" id="post">
    <header class="post-header text-center">
      <h1 class="title">JavaScript基础</h1>
      <span>
        
        <time class="time" datetime="2021-12-20T10:40:53.000Z">
          2021-12-20
        </time>
        
      </span>
      <span class="slash">/</span>
      <span class="post-meta">
        <span class="post-tags">
          <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/nmd/" rel="tag">nmd</a></li></ul>
        </span>
      </span>
      <span class="slash">/</span>
      <span class="read"> <span id="busuanzi_value_page_pv"></span> 点击 </span>
      <span class="slash">/</span>
    </header>

    <div class="post-content"><h1 id="JavaScript-基础"><a href="#JavaScript-基础" class="headerlink" title="JavaScript 基础"></a>JavaScript 基础</h1><p>​ 前端三剑客 html，css，还有 JavaScript。可以这么说，在后续写的一个项目的代码种，90%以上都是 JavaScript 代码。所以说想成为一名优秀的前端工程师，对 JavaScript 要有深刻理解和出神入化的应用能力。是、如果说 html 和 css 说是冰山上的上半部分，而 JavaScript 就是冰山下面隐藏的大部分。</p>
<h2 id="什么是-JavaScript？"><a href="#什么是-JavaScript？" class="headerlink" title="什么是 JavaScript？"></a>什么是 JavaScript？</h2><p>​ JavaScript（简称“JS”） 是一种具有函数优先的<strong>轻量级</strong>，<strong>解释型或即时编译型</strong>的<strong>弱类型</strong><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/9845131">编程语言</a>。虽然它是作为开发<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/Web/150564">Web</a>页面的<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80/1379708">脚本语言</a>而出名，但是它也被用到了很多非<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%B5%8F%E8%A7%88%E5%99%A8/213911">浏览器</a>环境中，JavaScript 基于原型编程、多范式的动态脚本语言，并且支持<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/2262089">面向对象</a>、命令式、声明式、<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%87%BD%E6%95%B0/301912">函数</a>式编程范式。</p>
<h3 id="JavaScript-和由来和回顾"><a href="#JavaScript-和由来和回顾" class="headerlink" title="JavaScript 和由来和回顾"></a>JavaScript 和由来和回顾</h3><p>​ 1995 年，网景公司一名叫做 Brendan Eich 的工程师，开始为即将发布的 Netscape Navigator 2 开发一个叫 Mocha 的脚本语言。当时的计划就是在客户端和服务器端都使用它，它在服务器端叫 LiveWire。后来在与另外一个公司共同开发出在客户端的叫 LiveScipt 的脚本语言。在正式发行之前，网景决定将浏览器的名字由 LiveScipt 改为 JavaScript。</p>
<h2 id="JavaScript-简介"><a href="#JavaScript-简介" class="headerlink" title="JavaScript 简介"></a>JavaScript 简介</h2><p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20211124171437354.png" alt="image-20211124171437354"></p>
<p>大家可能听过 ECMAscript，其实他对应的则是 JavaScript 的版本标准。但是 JavaScript 不仅仅限制于 ECMAscript。JavaScript 的核心有以下三个。</p>
<ul>
<li>核心（ECMAscript）</li>
<li>文档对象模型（DOM）</li>
<li>浏览器对象模型（BOM）</li>
</ul>
<h2 id="函数-Function-heavy-check-mark"><a href="#函数-Function-heavy-check-mark" class="headerlink" title="函数 Function:heavy_check_mark:"></a>函数 Function:heavy_check_mark:</h2><p>如果要说 Js 相比于其他语言的特色的话，函数绝对是区别很大的一项。</p>
<p>函数的本质其实就是一种行为，</p>
<p>eg:假如我今天很生气，我要打一个人就是一个行为，然后结果不巧张三碰到我，就被我打了，张三就是被我打的对象。</p>
<p>事实上我们不只是可以打张三，碰到了李四也一样的打李四。</p>
<p>打就是对这个行为的实施</p>
<p>所以说打一个人就是我们定义的定义的行为，人就是形参，被打的人就是实参</p>
<p>所以我们可以构造下列一个函数,函数式的编程其实也是从某一方面来说反映了面向对象编程的编程方式。就向大家的老话常说，</p>
<p>把大象放进冰箱。</p>
<p>函数的调用可以通过函数名加( )的方式进行调用！</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function beat(a)&#123;</span><br><span class="line">	console.log(a+&quot;被打了&quot;)</span><br><span class="line">&#125;</span><br><span class="line">beat(&quot;张三&quot;);</span><br></pre></td></tr></table></figure>

<p>如何定义一个函数呢，以下有四种方法。</p>
<ul>
<li><strong>函数声明定义法</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function sum()&#123;</span><br><span class="line">	//代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>函数表达式定义法</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var a = function()&#123;</span><br><span class="line">	//代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>构造函数定义法</strong>(了解)</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let sum = new Function(&quot;num1&quot;,&quot;num2&quot;,return num1+num2)</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>箭头函数(了解)</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let demo=()=&gt;&#123;</span><br><span class="line">	//代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过上述方法，我们就在定义的许多函数。可以在别的地方进行调用。</p>
<p><strong>同时实参可以传入任意类型的值，什么都可以！</strong></p>
<p>函数在执行完以后，其中定义的变量就会被销毁，不能再被使用（闭包除外），当然也可以使用 return 提前终止函数。</p>
<h3 id="return"><a href="#return" class="headerlink" title="return"></a>return</h3><p>函数中的 return 则会将函数提前终止，并且将 return 的值返回给当前函数名。</p>
<p>在 js 中 return 可以返回所有的基础数据类型，例如变量，Object,Function,String,Number 等等。例如下面的代码。</p>
<p>当 return 函数时，就会出现不可思议的一幕。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function demo()&#123;</span><br><span class="line">	return function()&#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：所有函数的函数名为其本身的引用，局部定义的变量和函数会在函数调用完毕以后被销毁。</p>
<h3 id="JS-执行上下文和作用域"><a href="#JS-执行上下文和作用域" class="headerlink" title="JS 执行上下文和作用域"></a>JS 执行上下文和作用域</h3><p><strong>执行上下文</strong>的概念在 JavaScript 里面是非常重要的。变量和函数的上下文决定了它们可以访问哪些数据，以及它们的行为。每一个上下文都有一个关联的<strong>变量对象</strong>，而这个上下文对象中定义的所有变量和函数都存在于这个变量上。</p>
<p>虽然我们没有访问变量对象的权限，但是在后台处理数据时就会用到他。</p>
<p><strong>全局上下文</strong>是最外层的上下文，在浏览器中也就是我们最熟的 window 全局对象。因此所有通过 var 定义的全局变量和方法都会成为我们常说的 window 对方和方法。</p>
<p>而当定义的函数执行时，就会开辟一个新的上下文，同时会创建变量对象的一个作用域链。当上下文执行完毕时，上下文的变量对象就会被销毁。</p>
<p>可以看一看下面这个例子体会一下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var color = &quot;blue&quot;;</span><br><span class="line">function changeColor() &#123;</span><br><span class="line">  if (color === &quot;blue&quot;) &#123;</span><br><span class="line">    color = &quot;red&quot;;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    color = &quot;blue&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">changeColor();</span><br></pre></td></tr></table></figure>

<p>在这里对 changeColor 的调用会开辟一个新的上下文并去执行内部的代码并创建变量对象的一个作用域链指向之前上下文的变量对象。</p>
<p>这个作用域链条就决定了各级上下文在访问变量和函数时的顺序。代码正在指执行的上下文的变量对象始终位于作用域链的最前端。</p>
<p>上下就可以转化为以下表示</p>
<p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20211125183546053.png" alt="image-20211125183546053"></p>
<p>指向的正是 window 的变量对象。</p>
<p>当 changeColor 寻找自身变量对象没有找到的时候，就会再上到 window 变量对象去寻找，没有找到就报错。</p>
<p>所以依托这个特性，我们就可以大胆的在函数里调用函数，在函数上下文之上再创建一个新的上下文，对变量的寻找从而也变成类似于一条链子，没找到就不断地向上去寻找。</p>
<h3 id="作用域链-exclamation"><a href="#作用域链-exclamation" class="headerlink" title="作用域链:exclamation:"></a>作用域链:exclamation:</h3><p>充分了解作用域链是掌握 JavaScript 函数式编程必不可少的一步。</p>
<p><strong>当我们访问一个函数中没有的变量时，js 会再去上一个作用域去寻找变量，知道找到最上面的作用域也没有的话就会抛出错误，变量未定义.</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var a = 1;</span><br><span class="line">function demo1() &#123;</span><br><span class="line">  var b = 2;</span><br><span class="line">  function demo2() &#123;</span><br><span class="line">    function demo3() &#123;</span><br><span class="line">      var c = 3;</span><br><span class="line">      console.log(a);</span><br><span class="line">    &#125;</span><br><span class="line">    demo3();</span><br><span class="line">    console.log(c);//报错,c未定义</span><br><span class="line">  &#125;</span><br><span class="line">  demo2();</span><br><span class="line">&#125;</span><br><span class="line">demo1();</span><br></pre></td></tr></table></figure>

<h3 id="立即执行函数"><a href="#立即执行函数" class="headerlink" title="立即执行函数"></a>立即执行函数</h3><p>通过(函数体)()的方式，可以在声明完函数后进行立即调用，同时其中的变量也会在函数结束以后立即销毁。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(function demo()&#123;</span><br><span class="line">	console.log(&quot;我声明后就可以立马调用&quot;)</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong>demo 在执行完以后其存储空间就会被直接销毁,后续代码无法再调用 demo，适合一些只需要执行一遍就不用再执行的函数！</p>
<h2 id="关键字-var-amp-amp-let-amp-amp-const-zap"><a href="#关键字-var-amp-amp-let-amp-amp-const-zap" class="headerlink" title="关键字 var&amp;&amp;let&amp;&amp;const:zap:"></a>关键字 var&amp;&amp;let&amp;&amp;const:zap:</h2><p>在 JavaScript 种一共存在三种声明变量的方式，var,let,const.其中的 let 和 const 是 js 在 2016 年也就是 es6 的版本种提出的新规范。在此之前程序员一直都是使用的 var 关键字做声明。</p>
<p>先说说三者的区别</p>
<ul>
<li>var：为函数级作用域声明,声明时变量提升,定义的变量可以被更改，可以多次声明</li>
<li>let：为块级作用域声明，声明时产生暂时性死区，定义的变量可以被更改，只能声明一次</li>
<li>const：为块级作用域声明，声明时产生暂时性死区，定义的变量<strong>不可以被更改</strong>，只能声明一次</li>
</ul>
<p>我们可以写用以上写出一行标志性代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var words = &quot;Hello，World！&quot;;</span><br><span class="line">console.log(words);</span><br></pre></td></tr></table></figure>

<p>然后我们在控制台就可以看到我们想要的字符串打印出来。</p>
<p>在这里就是使用 var 关键字定义一个变量并且给它赋值为”Hello，World！</p>
<p>当我们换成另外两种变量声明方式时，结果并没有任何改变，可知其他两个关键字并不会对赋值的结果进行更改。</p>
<p><strong>注意：</strong>全局作用域中，let 创建的变量不会加在 window 对象身上，而 var 会。</p>
<h3 id="var-变量提升"><a href="#var-变量提升" class="headerlink" title="var 变量提升"></a>var 变量提升</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log(a);</span><br><span class="line">var a = 1; //undefined</span><br></pre></td></tr></table></figure>

<p>本来在我们眼中应该报错的代码，在这里却获得了一个 undefined。</p>
<p>说明在使用 var 定义 a 的时候，js 内部默认先将 var 声明的变量放在最前面。</p>
<p>所以以上代码实际实行顺序为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var a;</span><br><span class="line">console.log(a);</span><br><span class="line">a = 1;</span><br></pre></td></tr></table></figure>

<p>所以这里把 a 的声明放在最前面然后在后面再进行一个赋值。</p>
<p>而使用当我们使用 let 时会发现给到了我们想要的结果，这也说明了 let 不会有变量提升。</p>
<p>当然变量提升是一个非常不好的规范，和下面作用域结合会带来会带来很多代码迷惑行为。</p>
<h3 id="var-函数作用域和-let-块作用域"><a href="#var-函数作用域和-let-块作用域" class="headerlink" title="var 函数作用域和 let 块作用域"></a>var 函数作用域和 let 块作用域</h3><p>在用 var 定义变量是以一个函数作用域为一个区域</p>
<p>而用 let 声明范围则为一个块级作用域。以 for 循环举栗子:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function demo() &#123;</span><br><span class="line">  for (var i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">    // console.log(i);</span><br><span class="line">  &#125;</span><br><span class="line">  console.log(i);//10</span><br><span class="line">&#125;</span><br><span class="line">demo();</span><br></pre></td></tr></table></figure>

<p>而换成 let 的时候就得到了我们想要的结果，这就说明了两者的区别，我们也可以用{}去尝试，也是我们预想的结果。</p>
<p>故当变量用 let 声明时，会沿着块级作用域链去查找，进而找到我们想要的那个值。const 除了不能修改以外，与 let 同理。</p>
<h3 id="let-const-暂时性死区"><a href="#let-const-暂时性死区" class="headerlink" title="let,const 暂时性死区"></a>let,const 暂时性死区</h3><p>为什么 let 和 const 在声明时不会出现提升呢，其实时因为 let 和 const 在声明时会对当前块作用域进行封锁，任何在 let 声明变量之前引用变量时都会使得代码抛出异常从而使得程序终止。</p>
<h3 id="推荐使用声明方法"><a href="#推荐使用声明方法" class="headerlink" title="推荐使用声明方法"></a>推荐使用声明方法</h3><p>**1、不使用 var **</p>
<p>有了 let 和 const，大多数开发者会发现自己不再需要 var 了。限制了自己之使用 let 和 const 有助于提升代码质量，因为变量有了明确的作用域、声明位置，以及不变的值。</p>
<p>**2、const 优先、let 次之 **</p>
<p>使用 const 声明可以让浏览器运行时保持变量不变，也可以让静态代码分析工具提前发现不合法的赋值操作。因此，很多开发者认为应该优先使用 const 来声明变量，只有提前知道未来会有修改时，再使用 let。这样可以让开发者更有信心地推断某些变量地值永远不会改变，同时也能迅速地发现因意外赋值再导致地非预期行为。</p>
<h2 id="关于-debug"><a href="#关于-debug" class="headerlink" title="关于 debug"></a>关于 debug</h2><p>众所周知，如果有什么能让程序员心态崩溃的，那么一定就是项目中的 bug 了。如何高效率的处理 bug 是成为一名优秀开发者的必修路，我在这里暂且介绍两个 debug 方法</p>
<p>**方法一 ** console.log( )（推荐）</p>
<p>​ 用 console.log( )方法来对你想要的值进行一个打印从而判断当前程序按着你预期的方向执行，并且在发现 bug 时，往往一个打印就会让你知道你的问题出在哪里。</p>
<p><strong>方法二</strong> 浏览器 debug 工具</p>
<p>​ 通过检查打开网页的开发者工具，我们可以看到上面有很多很多功能。而在来源栏就有我们需要的工具，在下方找到自己创建的 js 文件然后在左侧栏打一个断点再刷新网页就可以开启网页的 debug 模式，来实时检测代码的运行！</p>
<h2 id="函数中的-this"><a href="#函数中的-this" class="headerlink" title="函数中的 this"></a>函数中的 this</h2><p>言归正传，this 是什么？首先记住 this 不是指向自身！this 就是一个指针，指向调用函数的对象，根据被调用函数当前的环境来定。</p>
<p>为了能够一眼看出 this 指向的是什么，我们首先需要知道 this 的绑定规则有哪些？</p>
<ol>
<li>默认绑定</li>
<li>隐式绑定</li>
<li>显式绑定</li>
<li>new 绑定</li>
</ol>
<p>上面的名词，你也许听过，也许没听过，但是今天之后，请牢牢记住。我们将依次来进行解析。</p>
<h3 id="默认绑定"><a href="#默认绑定" class="headerlink" title="默认绑定"></a>默认绑定</h3><p>默认绑定，在不能应用其它绑定规则时使用的默认规则，通常是独立函数调用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function sayHi()&#123;</span><br><span class="line">    console.log(&#x27;Hello,&#x27;, this.name);</span><br><span class="line">&#125;</span><br><span class="line">var name = &#x27;YvetteLau&#x27;;</span><br><span class="line">sayHi();</span><br></pre></td></tr></table></figure>

<p>在调用 Hi()时，应用了默认绑定，this 指向全局对象（非严格模式下），严格模式下，this 指向 undefined，undefined 上没有 this 对象，会抛出错误。</p>
<p>上面的代码，如果在浏览器环境中运行，那么结果就是 Hello,YvetteLau</p>
<p>但是如果在 node 环境中运行，结果就是 Hello,undefined.这是因为 node 中 name 并不是挂在全局对象上的。</p>
<p>本文中，如不特殊说明，默认为浏览器环境执行结果。</p>
<h3 id="隐式绑定"><a href="#隐式绑定" class="headerlink" title="隐式绑定"></a>隐式绑定</h3><p>函数的调用是在某个对象上触发的，即调用位置上存在上下文对象。典型的形式为 XXX.fun().我们来看一段代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function sayHi()&#123;</span><br><span class="line">    console.log(&#x27;Hello,&#x27;, this.name);</span><br><span class="line">&#125;</span><br><span class="line">var person = &#123;</span><br><span class="line">    name: &#x27;YvetteLau&#x27;,</span><br><span class="line">    sayHi: sayHi</span><br><span class="line">&#125;</span><br><span class="line">var name = &#x27;Wiliam&#x27;;</span><br><span class="line">person.sayHi();</span><br></pre></td></tr></table></figure>

<p>打印的结果是 Hello,YvetteLau.</p>
<p>sayHi 函数声明在外部，严格来说并不属于 person，但是在调用 sayHi 时,调用位置会使用 person 的上下文来引用函数，隐式绑定会把函数调用中的 this(即此例 sayHi 函数中的 this)绑定到这个上下文对象（即此例中的 person）</p>
<p>需要注意的是：对象属性链中只有最后一层会影响到调用位置。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function sayHi()&#123;</span><br><span class="line">    console.log(&#x27;Hello,&#x27;, this.name);</span><br><span class="line">&#125;</span><br><span class="line">var person2 = &#123;</span><br><span class="line">    name: &#x27;Christina&#x27;,</span><br><span class="line">    sayHi: sayHi</span><br><span class="line">&#125;</span><br><span class="line">var person1 = &#123;</span><br><span class="line">    name: &#x27;YvetteLau&#x27;,</span><br><span class="line">    friend: person2</span><br><span class="line">&#125;</span><br><span class="line">person1.friend.sayHi();</span><br></pre></td></tr></table></figure>

<p>结果是：Hello, Christina.</p>
<p>因为只有最后一层会确定 this 指向的是什么，不管有多少层，在判断 this 的时候，我们只关注最后一层，即此处的 friend。</p>
<p>隐式绑定有一个大陷阱，绑定很容易丢失(或者说容易给我们造成误导，我们以为 this 指向的是什么，但是实际上并非如此).</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function sayHi()&#123;</span><br><span class="line">    console.log(&#x27;Hello,&#x27;, this.name);</span><br><span class="line">&#125;</span><br><span class="line">var person = &#123;</span><br><span class="line">    name: &#x27;YvetteLau&#x27;,</span><br><span class="line">    sayHi: sayHi</span><br><span class="line">&#125;</span><br><span class="line">var name = &#x27;Wiliam&#x27;;</span><br><span class="line">var Hi = person.sayHi;</span><br><span class="line">Hi();</span><br></pre></td></tr></table></figure>

<h3 id="显式绑定"><a href="#显式绑定" class="headerlink" title="显式绑定"></a>显式绑定</h3><p>显式绑定比较好理解，就是通过 call,apply,bind 的方式，显式的指定 this 所指向的对象。</p>
<h4 id="call-apply-bind"><a href="#call-apply-bind" class="headerlink" title="call,apply,bind"></a><strong>call,apply,bind</strong></h4><p>首先先给大家讲解一下 call,apply,bind</p>
<p>call,apply 和 bind 的第一个参数，就是对应函数的 this 所指向的对象，使用 apply、call、bind 函数可以改变 this 的指向的。call 和 apply 的作用一样，只是传参方式不同。call 和 apply 都会执行对应的函数，而 bind 方法不会。</p>
<p>以下为例子</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">var a = &#123;</span><br><span class="line">  name: &quot;Cherry&quot;,</span><br><span class="line">  func1: function (haha,xixi) &#123;</span><br><span class="line">    console.log(haha);</span><br><span class="line">    console.log(xixi);</span><br><span class="line">    console.log(this.name);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">var b =&#123;</span><br><span class="line">	 name: &quot;Bill&quot;,</span><br><span class="line">&#125;</span><br><span class="line">a.func1.apply(b, [1,2]);</span><br><span class="line">//1</span><br><span class="line">//2</span><br><span class="line">//Bill</span><br><span class="line">以上代码以下代码等价</span><br><span class="line">a.fun1.call(b,1,2);</span><br><span class="line">一个传数组，一个直接以形式参数的方式传递!</span><br></pre></td></tr></table></figure>

<p>然后在下面就可以开始表演!</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function sayHi()&#123;</span><br><span class="line">    console.log(&#x27;Hello,&#x27;, this.name);</span><br><span class="line">&#125;</span><br><span class="line">var person = &#123;</span><br><span class="line">    name: &#x27;YvetteLau&#x27;,</span><br><span class="line">    sayHi: sayHi</span><br><span class="line">&#125;</span><br><span class="line">var name = &#x27;Wiliam&#x27;;</span><br><span class="line">var Hi = person.sayHi;</span><br><span class="line">Hi.call(person); //Hi.apply(person)</span><br></pre></td></tr></table></figure>

<p>输出的结果为: Hello, YvetteLau. 因为使用显式绑定明确将 this 绑定在了 person 上。</p>
<h2 id="Array-数组"><a href="#Array-数组" class="headerlink" title="Array 数组"></a>Array 数组</h2><p>除了 Object，Array 应该就是 ECMAScript 中最常用的类型了。ECMAScript 数组跟其他编程语言的数组有很大的区别。跟别的编程语言中的数组一样，ECMAScript 数组也是一组有序的数据，但跟其他语言的不同的是，数组中的每一个槽位可以存储任意类型的数据。这意味可以创建一个数组如下,且数组是动态的，可以随着数据添加而自动增长。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1,&quot;haha&quot;,&#123;&#125;,true,()=&gt;&#123;&#125;]</span><br></pre></td></tr></table></figure>

<p>创建数组的方法有以下这些</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let number  = new Arrary(1,2,3)</span><br></pre></td></tr></table></figure>

<h3 id="改变原数组的方法-7-个"><a href="#改变原数组的方法-7-个" class="headerlink" title="改变原数组的方法(7 个):"></a><em>改变原数组的方法(7 个):</em></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let a = [1,2,3];</span><br><span class="line">ES5:</span><br><span class="line"> a.splice()/ a.sort() / a.pop()/ a.shift()/  a.push()/ a.unshift()/ a.reverse()</span><br></pre></td></tr></table></figure>

<p>对于这些能够改变原数组的方法，要注意避免在循环遍历中改变原数组的选项，比如: 改变数组的长度，导致遍历的长度出现问题。</p>
<h4 id="splice-添加-删除数组元素"><a href="#splice-添加-删除数组元素" class="headerlink" title="splice() 添加/删除数组元素"></a>splice() 添加/删除数组元素</h4><p>定义： splice() 方法<strong>向/从数组中添加/删除</strong>项目，然后返回被删除的项目</p>
<p>语法： <code>array.splice(index,howmany,item1,.....,itemX)</code></p>
<p>参数:</p>
<ol>
<li>index：必需。整数，规定添加/删除项目的位置，使用负数可从数组结尾处规定位置。</li>
<li>howmany：可选。要删除的项目数量。如果设置为 0，则不会删除项目。</li>
<li>item1, …, itemX： 可选。向数组添加的新项目。</li>
</ol>
<p>返回值: 如果有元素被删除,返回包含被删除项目的新数组。</p>
<p>eg1:删除元素</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let a = [1, 2, 3, 4, 5, 6, 7];</span><br><span class="line">let item = a.splice(0, 3); // [1,2,3]</span><br><span class="line">console.log(a); // [4,5,6,7]</span><br><span class="line">// 从数组下标0开始，删除3个元素</span><br><span class="line">let item = a.splice(-1, 3); // [7]</span><br><span class="line">// 从最后一个元素开始删除3个元素，因为最后一个元素，所以只删除了7</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>eg2: 删除并添加</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> let a = [1, 2, 3, 4, 5, 6, 7];</span><br><span class="line">let item = a.splice(0,3,&#x27;添加&#x27;); // [1,2,3]</span><br><span class="line">console.log(a); // [&#x27;添加&#x27;,4,5,6,7]</span><br><span class="line">// 从数组下标0开始，删除3个元素，并添加元素&#x27;添加&#x27;</span><br><span class="line"> let b = [1, 2, 3, 4, 5, 6, 7];</span><br><span class="line">let item = b.splice(-2,3,&#x27;添加1&#x27;,&#x27;添加2&#x27;); // [6,7]</span><br><span class="line">console.log(b); // [1,2,3,4,5,&#x27;添加1&#x27;,&#x27;添加2&#x27;]</span><br><span class="line">// 从数组最后第二个元素开始，删除3个元素，并添加两个元素&#x27;添加1&#x27;、&#x27;添加2&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>eg3: 不删除只添加:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let a = [1, 2, 3, 4, 5, 6, 7];</span><br><span class="line">let item = a.splice(0,0,&#x27;添加1&#x27;,&#x27;添加2&#x27;); // [] 没有删除元素，返回空数组</span><br><span class="line">console.log(a); // [&#x27;添加1&#x27;,&#x27;添加2&#x27;,1,2,3,4,5,6,7]</span><br><span class="line">let b = [1, 2, 3, 4, 5, 6, 7];</span><br><span class="line">let item = b.splice(-1,0,&#x27;添加1&#x27;,&#x27;添加2&#x27;); // [] 没有删除元素，返回空数组</span><br><span class="line">console.log(b); // [1,2,3,4,5,6,&#x27;添加1&#x27;,&#x27;添加2&#x27;,7] 在最后一个元素的前面添加两个元素</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>从上述三个栗子可以得出:</p>
<ol>
<li>数组如果元素不够，会删除到最后一个元素为止</li>
<li>操作的元素，包括开始的那个元素</li>
<li>可以添加很多个元素</li>
<li>添加是在开始的元素前面添加的</li>
</ol>
<h4 id="sort-数组排序"><a href="#sort-数组排序" class="headerlink" title="sort() 数组排序"></a>sort() 数组排序</h4><p>定义: sort()方法对数组元素进行排序，并返回这个数组。</p>
<p>参数可选: 规定排序顺序的比较函数。</p>
<p>默认情况下 sort()方法没有传比较函数的话，默认按字母升序，如果不是元素不是字符串的话，会调用<code>toString()</code>方法将元素转化为字符串的 Unicode(万国码)位点，然后再比较字符。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 字符串排列 看起来很正常</span><br><span class="line">var a = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];</span><br><span class="line">a.sort(); // [&quot;Apple&quot;,&quot;Banana&quot;,&quot;Mango&quot;,&quot;Orange&quot;]</span><br><span class="line">// 数字排序的时候 因为转换成Unicode字符串之后，有些数字会比较大会排在后面 这显然不是我们想要的</span><br><span class="line">var	a = [10, 1, 3, 20,25,8];</span><br><span class="line">console.log(a.sort()) // [1,10,20,25,3,8];</span><br></pre></td></tr></table></figure>

<p><strong>比较函数的两个参数：</strong></p>
<p>sort 的比较函数有两个默认参数，要在函数中接收这两个参数，这两个参数是数组中两个要比较的元素，通常我们用 a 和 b 接收两个将要比较的元素：</p>
<ul>
<li>若比较函数返回值&lt;0，那么 a 将排到 b 的前面;</li>
<li>若比较函数返回值=0，那么 a 和 b 相对位置不变；</li>
<li>若比较函数返回值&gt;0，那么 b 排在 a 将的前面；</li>
</ul>
<p>对于 sort()方法更深层级的内部实现以及处理机制可以看一下这篇文章<a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903507439419399">深入了解 javascript 的 sort 方法</a></p>
<p><strong>sort 排序常见用法</strong>：</p>
<ol>
<li><p>数组元素为数字的升序、降序:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var array =  [10, 1, 3, 4,20,4,25,8];</span><br><span class="line">// 升序 a-b &lt; 0   a将排到b的前面，按照a的大小来排序的</span><br><span class="line">// 比如被减数a是10，减数是20  10-20 &lt; 0   被减数a(10)在减数b(20)前面</span><br><span class="line">array.sort(function(a,b)&#123;</span><br><span class="line">  return a-b;</span><br><span class="line">&#125;);</span><br><span class="line">console.log(array); // [1,3,4,4,8,10,20,25];</span><br><span class="line">// 降序 被减数和减数调换了  20-10&gt;0 被减数b(20)在减数a(10)的前面</span><br><span class="line">array.sort(function(a,b)&#123;</span><br><span class="line">  return b-a;</span><br><span class="line">&#125;);</span><br><span class="line">console.log(array); // [25,20,10,8,4,4,3,1];</span><br></pre></td></tr></table></figure></li>
<li><p>数组多条件排序</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var array = [&#123;id:10,age:2&#125;,&#123;id:5,age:4&#125;,&#123;id:6,age:10&#125;,&#123;id:9,age:6&#125;,&#123;id:2,age:8&#125;,&#123;id:10,age:9&#125;];</span><br><span class="line">    array.sort(function(a,b)&#123;</span><br><span class="line">        if(a.id === b.id)&#123;// 如果id的值相等，按照age的值降序</span><br><span class="line">            return b.age - a.age</span><br><span class="line">        &#125;else&#123; // 如果id的值不相等，按照id的值升序</span><br><span class="line">            return a.id - b.id</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"> // [&#123;&quot;id&quot;:2,&quot;age&quot;:8&#125;,&#123;&quot;id&quot;:5,&quot;age&quot;:4&#125;,&#123;&quot;id&quot;:6,&quot;age&quot;:10&#125;,&#123;&quot;id&quot;:9,&quot;age&quot;:6&#125;,&#123;&quot;id&quot;:10,&quot;age&quot;:9&#125;,&#123;&quot;id&quot;:10,&quot;age&quot;:2&#125;]</span><br></pre></td></tr></table></figure></li>
<li><p>自定义比较函数，天空才是你的极限</p>
</li>
</ol>
<p>类似的：<strong>运用好返回值，我们可以写出任意符合自己需求的比较函数</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var array = [&#123;name:&#x27;Koro1&#x27;&#125;,&#123;name:&#x27;Koro1&#x27;&#125;,&#123;name:&#x27;OB&#x27;&#125;,&#123;name:&#x27;Koro1&#x27;&#125;,&#123;name:&#x27;OB&#x27;&#125;,&#123;name:&#x27;OB&#x27;&#125;];</span><br><span class="line">array.sort(function(a,b)&#123;</span><br><span class="line">    if(a.name === &#x27;Koro1&#x27;)&#123;// 如果name是&#x27;Koro1&#x27; 返回-1 ，-1&lt;0 a排在b的前面</span><br><span class="line">        return -1</span><br><span class="line">    &#125;else&#123; // 如果不是的话，a排在b的后面</span><br><span class="line">      return 1</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">// [&#123;&quot;name&quot;:&quot;Koro1&quot;&#125;,&#123;&quot;name&quot;:&quot;Koro1&quot;&#125;,&#123;&quot;name&quot;:&quot;Koro1&quot;&#125;,&#123;&quot;name&quot;:&quot;OB&quot;&#125;,&#123;&quot;name&quot;:&quot;OB&quot;&#125;,&#123;&quot;name&quot;:&quot;OB&quot;&#125;]</span><br></pre></td></tr></table></figure>

<h4 id="pop-删除一个数组中的最后的一个元素"><a href="#pop-删除一个数组中的最后的一个元素" class="headerlink" title="pop() 删除一个数组中的最后的一个元素"></a>pop() 删除一个数组中的最后的一个元素</h4><p>定义: pop() 方法删除一个数组中的最后的一个元素，并且返回这个元素。</p>
<p>参数: 无。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let  a =  [1,2,3];</span><br><span class="line">let item = a.pop();  // 3</span><br><span class="line">console.log(a); // [1,2]</span><br></pre></td></tr></table></figure>

<h4 id="shift-删除数组的第一个元素"><a href="#shift-删除数组的第一个元素" class="headerlink" title="shift() 删除数组的第一个元素"></a>shift() 删除数组的第一个元素</h4><p>定义: shift()方法删除数组的第一个元素，并返回这个元素。</p>
<p>参数: 无。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let  a =  [1,2,3];</span><br><span class="line">let item = a.shift();  // 1</span><br><span class="line">console.log(a); // [2,3]</span><br></pre></td></tr></table></figure>

<h4 id="push-向数组的末尾添加元素"><a href="#push-向数组的末尾添加元素" class="headerlink" title="push() 向数组的末尾添加元素"></a>push() 向数组的末尾添加元素</h4><p>定义：push() 方法可向数组的末尾添加一个或多个元素，并返回新的长度。</p>
<p>参数: item1, item2, …, itemX ,要添加到数组末尾的元素</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let  a =  [1,2,3];</span><br><span class="line">let item = a.push(&#x27;末尾&#x27;);  // 4</span><br><span class="line">console.log(a); // [1,2,3,&#x27;末尾&#x27;]</span><br></pre></td></tr></table></figure>

<h4 id="unshift"><a href="#unshift" class="headerlink" title="unshift()"></a>unshift()</h4><p>定义：unshift() 方法可向数组的开头添加一个或更多元素，并返回新的长度。</p>
<p>参数: item1, item2, …, itemX ,要添加到数组开头的元素</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let  a =  [1,2,3];</span><br><span class="line">let item = a.unshift(&#x27;开头&#x27;);  // 4</span><br><span class="line">console.log(a); // [&#x27;开头&#x27;,1,2,3]</span><br></pre></td></tr></table></figure>

<h4 id="reverse-颠倒数组中元素的顺序"><a href="#reverse-颠倒数组中元素的顺序" class="headerlink" title="reverse() 颠倒数组中元素的顺序"></a>reverse() 颠倒数组中元素的顺序</h4><p>定义: reverse() 方法用于颠倒数组中元素的顺序。</p>
<p>参数: 无</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let  a =  [1,2,3];</span><br><span class="line">a.reverse();</span><br><span class="line">console.log(a); // [3,2,1]</span><br></pre></td></tr></table></figure>

<p>填充的结束位置，默认是为<code>this.length</code></p>
<hr>
<h3 id="不改变原数组的方法-8-个"><a href="#不改变原数组的方法-8-个" class="headerlink" title="不改变原数组的方法(8 个):"></a><em>不改变原数组的方法(8 个):</em></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slice、join、toLocateString、toStrigin、cancat、indexOf、lastIndexOf、</span><br></pre></td></tr></table></figure>

<h4 id="slice-浅拷贝数组的元素"><a href="#slice-浅拷贝数组的元素" class="headerlink" title="slice() 浅拷贝数组的元素"></a>slice() 浅拷贝数组的元素</h4><p>定义： 方法返回一个从开始到结束（不包括结束）选择的数组的一部分浅拷贝到一个新数组对象，且原数组不会被修改。</p>
<p><strong>注意</strong>：字符串也有一个 slice() 方法是用来提取字符串的，不要弄混了。</p>
<p>语法:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array.slice(begin, end);</span><br></pre></td></tr></table></figure>

<p>参数:</p>
<p>begin(可选): 索引数值,接受负值，从该索引处开始提取原数组中的元素,默认值为 0。</p>
<p>end(可选):索引数值(不包括),接受负值，在该索引处前结束提取原数组元素，默认值为数组末尾(包括最后一个元素)。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let a= [&#x27;hello&#x27;,&#x27;world&#x27;];</span><br><span class="line">let b=a.slice(0,1); // [&#x27;hello&#x27;]</span><br><span class="line">a[0]=&#x27;改变原数组&#x27;;</span><br><span class="line">console.log(a,b); // [&#x27;改变原数组&#x27;,&#x27;world&#x27;] [&#x27;hello&#x27;]</span><br><span class="line">b[0]=&#x27;改变拷贝的数组&#x27;;</span><br><span class="line"> console.log(a,b); // [&#x27;改变原数组&#x27;,&#x27;world&#x27;] [&#x27;改变拷贝的数组&#x27;]</span><br></pre></td></tr></table></figure>

<p>如上：新数组是浅拷贝的，<strong>元素是简单数据类型，改变之后不会互相干扰</strong>。</p>
<p>如果是<strong>复杂数据类型(对象,数组)的话，改变其中一个，另外一个也会改变</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let a= [&#123;name:&#x27;OBKoro1&#x27;&#125;];</span><br><span class="line">let b=a.slice();</span><br><span class="line">console.log(b,a); // [&#123;&quot;name&quot;:&quot;OBKoro1&quot;&#125;]  [&#123;&quot;name&quot;:&quot;OBKoro1&quot;&#125;]</span><br><span class="line">// a[0].name=&#x27;改变原数组&#x27;;</span><br><span class="line">// console.log(b,a); // [&#123;&quot;name&quot;:&quot;改变原数组&quot;&#125;] [&#123;&quot;name&quot;:&quot;改变原数组&quot;&#125;]</span><br><span class="line">// b[0].name=&#x27;改变拷贝数组&#x27;,b[0].koro=&#x27;改变拷贝数组&#x27;;</span><br><span class="line">//  [&#123;&quot;name&quot;:&quot;改变拷贝数组&quot;,&quot;koro&quot;:&quot;改变拷贝数组&quot;&#125;] [&#123;&quot;name&quot;:&quot;改变拷贝数组&quot;,&quot;koro&quot;:&quot;改变拷贝数组&quot;&#125;]</span><br></pre></td></tr></table></figure>

<p>原因在定义上面说过了的：slice()是浅拷贝，对于复杂的数据类型浅拷贝，拷贝的只是指向原数组的指针，所以无论改变原数组，还是浅拷贝的数组，都是改变原数组的数据。</p>
<h4 id="join-数组转字符串"><a href="#join-数组转字符串" class="headerlink" title="join() 数组转字符串"></a>join() 数组转字符串</h4><p>定义: join() 方法用于把数组中的所有元素通过指定的分隔符进行分隔放入一个字符串，返回生成的字符串。</p>
<p>语法:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array.join(str)</span><br></pre></td></tr></table></figure>

<p>参数:</p>
<p>str(可选): 指定要使用的分隔符，默认使用逗号作为分隔符。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let a= [&#x27;hello&#x27;,&#x27;world&#x27;];</span><br><span class="line">let str=a.join(); // &#x27;hello,world&#x27;</span><br><span class="line">let str2=a.join(&#x27;+&#x27;); // &#x27;hello+world&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>使用 join 方法或者下文说到的 toString 方法时，当数组中的元素也是数组或者是对象时会出现什么情况？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let a= [[&#x27;OBKoro1&#x27;,&#x27;23&#x27;],&#x27;test&#x27;];</span><br><span class="line">let str1=a.join(); // OBKoro1,23,test</span><br><span class="line">let b= [&#123;name:&#x27;OBKoro1&#x27;,age:&#x27;23&#x27;&#125;,&#x27;test&#x27;];</span><br><span class="line">let str2 = b.join(); // [object Object],test</span><br><span class="line">// 对象转字符串推荐JSON.stringify(obj);</span><br></pre></td></tr></table></figure>

<p>所以，<code>join()/toString()</code>方法在数组元素是数组的时候，会将里面的数组也调用<code>join()/toString()</code>,如果是对象的话，对象会被转为<code>[object Object]</code>字符串。</p>
<h4 id="toLocaleString-数组转字符串"><a href="#toLocaleString-数组转字符串" class="headerlink" title="toLocaleString() 数组转字符串"></a>toLocaleString() 数组转字符串</h4><p>定义: 返回一个表示数组元素的字符串。该字符串由数组中的每个元素的 toLocaleString() 返回值经调用 join() 方法连接（由逗号隔开）组成。</p>
<p>语法:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array.toLocaleString()</span><br></pre></td></tr></table></figure>

<p>参数：无。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let a=[&#123;name:&#x27;OBKoro1&#x27;&#125;,23,&#x27;abcd&#x27;,new Date()];</span><br><span class="line">let str=a.toLocaleString(); // [object Object],23,abcd,2018/5/28 下午1:52:20</span><br></pre></td></tr></table></figure>

<p>如上述栗子：调用数组的<code>toLocaleString</code>方法，数组中的每个元素都会调用自身的<code>toLocaleString</code>方法，对象调用对象的<code>toLocaleString</code>,Date 调用 Date 的<code>toLocaleString</code>。</p>
<h4 id="toString-数组转字符串-不推荐"><a href="#toString-数组转字符串-不推荐" class="headerlink" title="toString() 数组转字符串 不推荐"></a>toString() 数组转字符串 不推荐</h4><p>定义: toString() 方法可把数组转换为由逗号链接起来的字符串。</p>
<p>语法:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array.toString()</span><br></pre></td></tr></table></figure>

<p>参数: 无。</p>
<p>该方法的效果和 join 方法一样，都是用于数组转字符串的，但是与 join 方法相比没有优势，也不能自定义字符串的分隔符，因此不推荐使用。</p>
<p><strong>值得注意的是</strong>：当数组和字符串操作的时候，js 会调用这个方法将数组自动转换成字符串</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let b= [ &#x27;toString&#x27;,&#x27;演示&#x27;].toString(); // toString,演示</span><br><span class="line">let a= [&#x27;调用toString&#x27;,&#x27;连接在我后面&#x27;]+&#x27;啦啦啦&#x27;; // 调用toString,连接在我后面啦啦啦</span><br></pre></td></tr></table></figure>

<h4 id="cancat"><a href="#cancat" class="headerlink" title="cancat"></a>cancat</h4><p>定义： 方法用于合并两个或多个数组，返回一个新数组。</p>
<p>语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var newArr =oldArray.concat(arrayX,arrayX,......,arrayX)</span><br></pre></td></tr></table></figure>

<p>参数：</p>
<p>arrayX（必须）：该参数可以是具体的值，也可以是数组对象。可以是任意多个。</p>
<p>eg1:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> let a = [1, 2, 3];</span><br><span class="line"> let b = [4, 5, 6];</span><br><span class="line"> //连接两个数组</span><br><span class="line"> let newVal=a.concat(b); // [1,2,3,4,5,6]</span><br><span class="line"> // 连接三个数组</span><br><span class="line"> let c = [7, 8, 9]</span><br><span class="line"> let newVal2 = a.concat(b, c); // [1,2,3,4,5,6,7,8,9]</span><br><span class="line"> // 添加元素</span><br><span class="line"> let newVal3 = a.concat(&#x27;添加元素&#x27;,b, c,&#x27;再加一个&#x27;);</span><br><span class="line"> // [1,2,3,&quot;添加元素&quot;,4,5,6,7,8,9,&quot;再加一个&quot;]</span><br><span class="line">// 合并嵌套数组  会浅拷贝嵌套数组</span><br><span class="line">let d = [1,2 ];</span><br><span class="line">let f = [3,[4]];</span><br><span class="line">let newVal4 = d.concat(f); // [1,2,3,[4]]</span><br></pre></td></tr></table></figure>

<p><strong>ES6 扩展运算符<code>...</code>合并数组</strong>：</p>
<p>因为 ES6 的语法更简洁易懂，所以现在合并数组我大部分采用<code>...</code>来处理，<code>...</code>运算符可以实现<code>cancat</code>的每个栗子，且更简洁和具有高度自定义数组元素位置的效果。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let a = [2, 3, 4, 5]</span><br><span class="line">let b = [ 4,...a, 4, 4]</span><br><span class="line">console.log(a,b); //  [2, 3, 4, 5] [4,2,3,4,5,4,4]</span><br></pre></td></tr></table></figure>

<p>更多关于扩展符的详细内容移步阮一峰大神的<a href="https://link.juejin.cn/?target=http://es6.ruanyifeng.com/%23docs/array%23%E6%89%A9%E5%B1%95%E8%BF%90%E7%AE%97%E7%AC%A6">ECMAScript 6 入门</a></p>
<h4 id="indexOf-查找数组是否存在某个元素，返回下标"><a href="#indexOf-查找数组是否存在某个元素，返回下标" class="headerlink" title="indexOf() 查找数组是否存在某个元素，返回下标"></a>indexOf() 查找数组是否存在某个元素，返回下标</h4><p>定义: 返回在数组中可以找到一个给定元素的第一个索引，如果不存在，则返回-1。</p>
<p>语法:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">array.indexOf(searchElement,fromIndex)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>参数:</p>
<p>searchElement(必须):被查找的元素</p>
<p>fromIndex(可选):开始查找的位置(不能大于等于数组的长度，返回-1)，接受负值，默认值为 0。</p>
<p>严格相等的搜索:</p>
<p>数组的 indexOf 搜索跟字符串的 indexOf 不一样,数组的 indexOf 使用严格相等<code>===</code>搜索元素，即<strong>数组元素要完全匹配</strong>才能搜索成功。</p>
<p><strong>注意</strong>：indexOf()不能识别<code>NaN</code></p>
<p>eg:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let a=[&#x27;啦啦&#x27;,2,4,24,NaN]</span><br><span class="line">console.log(a.indexOf(&#x27;啦&#x27;));  // -1</span><br><span class="line">console.log(a.indexOf(&#x27;NaN&#x27;));  // -1</span><br><span class="line">console.log(a.indexOf(&#x27;啦啦&#x27;)); // 0</span><br></pre></td></tr></table></figure>

<p>使用场景：</p>
<ol>
<li><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903577421365255#heading-10">数组去重</a></li>
<li>根据获取的数组下标执行操作，改变数组中的值等。</li>
<li>判断是否存在，执行操作。</li>
</ol>
<h4 id="lastIndexOf-查找指定元素在数组中的最后一个位置"><a href="#lastIndexOf-查找指定元素在数组中的最后一个位置" class="headerlink" title="lastIndexOf() 查找指定元素在数组中的最后一个位置"></a>lastIndexOf() 查找指定元素在数组中的最后一个位置</h4><p>定义: 方法返回指定元素,在数组中的最后一个的索引，如果不存在则返回 -1。（从数组后面往前查找）</p>
<p>语法:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr.lastIndexOf(searchElement,fromIndex)</span><br></pre></td></tr></table></figure>

<p>参数:</p>
<p>searchElement(必须): 被查找的元素</p>
<p>fromIndex(可选): 逆向查找开始位置，默认值数组的长度-1，即查找整个数组。</p>
<p>关于 fromIndex 有三个规则:</p>
<ol>
<li><p>正值。如果该值大于或等于数组的长度，则整个数组会被查找。</p>
</li>
<li><p>负值。将其视为从数组末尾向前的偏移。(比如-2，从数组最后第二个元素开始往前查找)</p>
</li>
<li><p>负值。其绝对值大于数组长度，则方法返回 -1，即数组不会被查找。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let a=[&#x27;OB&#x27;,4,&#x27;Koro1&#x27;,1,2,&#x27;Koro1&#x27;,3,4,5,&#x27;Koro1&#x27;]; // 数组长度为10</span><br><span class="line">// let b=a.lastIndexOf(&#x27;Koro1&#x27;,4); // 从下标4开始往前找 返回下标2</span><br><span class="line">// let b=a.lastIndexOf(&#x27;Koro1&#x27;,100); //  大于或数组的长度 查找整个数组 返回9</span><br><span class="line">// let b=a.lastIndexOf(&#x27;Koro1&#x27;,-11); // -1 数组不会被查找</span><br><span class="line">let b=a.lastIndexOf(&#x27;Koro1&#x27;,-9); // 从第二个元素4往前查找，没有找到 返回-1</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="遍历方法-4-个"><a href="#遍历方法-4-个" class="headerlink" title="遍历方法(4 个):"></a>遍历方法(4 个):</h3><p>js 中遍历数组并不会改变原始数组的方法总共有 4 个:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">forEachsome、 filter、map、reduce、</span><br></pre></td></tr></table></figure>

<h4 id="关于遍历："><a href="#关于遍历：" class="headerlink" title="关于遍历："></a>关于遍历：</h4><ul>
<li>关于遍历的效率，可以看一下这篇<a href="https://link.juejin.cn/?target=http://louiszhai.github.io/2015/12/18/traverse/%23%E6%B5%8B%E8%AF%95%E5%90%84%E6%96%B9%E6%B3%95%E6%95%88%E7%8E%87">详解 JS 遍历</a></li>
<li>尽量不要在遍历的时候，修改后面要遍历的值</li>
<li>尽量不要在遍历的时候修改数组的长度（删除/添加）</li>
</ul>
<h4 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h4><p>定义: 按升序为数组中含有效值的每一项执行一次回调函数。</p>
<p>语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">array.forEach(function(currentValue, index, arr), thisValue)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>参数:</p>
<p>function(必须): 数组中每个元素需要调用的函数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 回调函数的参数</span><br><span class="line">1. currentValue(必须),数组当前元素的值</span><br><span class="line">2. index(可选), 当前元素的索引值</span><br><span class="line">3. arr(可选),数组对象本身</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>thisValue(可选): 当执行回调函数时 this 绑定对象的值，默认值为<code>undefined</code></p>
<p><strong>关于 forEach()你要知道</strong>：</p>
<ul>
<li>无法中途退出循环，只能用<code>return</code>退出本次回调，进行下一次回调。</li>
<li>它总是返回 undefined 值,即使你 return 了一个值。</li>
</ul>
<p>下面类似语法同样适用这些规则</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. 对于空数组是不会执行回调函数的</span><br><span class="line">2. 对于已在迭代过程中删除的元素，或者空元素会跳过回调函数</span><br><span class="line">3. 遍历次数再第一次循环前就会确定，再添加到数组中的元素不会被遍历。</span><br><span class="line">4. 如果已经存在的值被改变，则传递给 callback 的值是遍历到他们那一刻的值。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="filter-过滤原始数组，返回新数组"><a href="#filter-过滤原始数组，返回新数组" class="headerlink" title="filter 过滤原始数组，返回新数组"></a>filter 过滤原始数组，返回新数组</h4><p>定义: 返回一个新数组, 其包含通过所提供函数实现的测试的所有元素。</p>
<p>语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let new_array = arr.filter(function(currentValue, index, arr), thisArg)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>参数:(这几个方法的参数，语法都类似)</p>
<p>function(必须): 数组中每个元素需要调用的函数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 回调函数的参数</span><br><span class="line">1. currentValue(必须),数组当前元素的值</span><br><span class="line">2. index(可选), 当前元素的索引值</span><br><span class="line">3. arr(可选),数组对象本身</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>thisValue(可选): 当执行回调函数时 this 绑定对象的值，默认值为<code>undefined</code></p>
<p>eg:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> let a = [32, 33, 16, 40];</span><br><span class="line">let result = a.filter(function (value, index, array) &#123;</span><br><span class="line">  return value &gt;= 18; // 返回a数组中所有大于18的元素</span><br><span class="line">&#125;);</span><br><span class="line">console.log(result,a);// [32,33,40] [32,33,16,40]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="map-对数组中的每个元素进行处理，返回新的数组"><a href="#map-对数组中的每个元素进行处理，返回新的数组" class="headerlink" title="map 对数组中的每个元素进行处理，返回新的数组"></a>map 对数组中的每个元素进行处理，返回新的数组</h4><p>定义：创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果。</p>
<p>语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let new_array = arr.map(function(currentValue, index, arr), thisArg)</span><br></pre></td></tr></table></figure>

<p>参数:(这几个方法的参数，语法都类似)</p>
<p>function(必须): 数组中每个元素需要调用的函数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 回调函数的参数</span><br><span class="line">1. currentValue(必须),数组当前元素的值</span><br><span class="line">2. index(可选), 当前元素的索引值</span><br><span class="line">3. arr(可选),数组对象本身</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>thisValue(可选): 当执行回调函数时 this 绑定对象的值，默认值为<code>undefined</code></p>
<p>eg:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let a = [&#x27;1&#x27;,&#x27;2&#x27;,&#x27;3&#x27;,&#x27;4&#x27;];</span><br><span class="line">let result = a.map(function (value, index, array) &#123;</span><br><span class="line">  return value + &#x27;新数组的新元素&#x27;</span><br><span class="line">&#125;);</span><br><span class="line">console.log(result, a);</span><br><span class="line">// [&quot;1新数组的新元素&quot;,&quot;2新数组的新元素&quot;,&quot;3新数组的新元素&quot;,&quot;4新数组的新元素&quot;] [&quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="reduce-为数组提供累加器，合并为一个值"><a href="#reduce-为数组提供累加器，合并为一个值" class="headerlink" title="reduce 为数组提供累加器，合并为一个值"></a>reduce 为数组提供累加器，合并为一个值</h4><p>定义：reduce() 方法对累加器和数组中的每个元素（从左到右）应用一个函数，最终合并为一个值。</p>
<p>语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">array.reduce(function(total, currentValue, currentIndex, arr), initialValue)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>参数：</p>
<p>function(必须): 数组中每个元素需要调用的函数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 回调函数的参数</span><br><span class="line">1. total(必须)，初始值, 或者上一次调用回调返回的值</span><br><span class="line">2. currentValue(必须),数组当前元素的值</span><br><span class="line">3. index(可选), 当前元素的索引值</span><br><span class="line">4. arr(可选),数组对象本身</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>initialValue(可选): 指定第一次回调 的第一个参数。</p>
<p>回调第一次执行时:</p>
<ul>
<li>如果 initialValue 在调用 reduce 时被提供，那么第一个 total 将等于 initialValue，此时 currentValue 等于数组中的第一个值；</li>
<li>如果 initialValue 未被提供，那么 total 等于数组中的第一个值，currentValue 等于数组中的第二个值。此时如果数组为空，那么将抛出 TypeError。</li>
<li>如果数组仅有一个元素，并且没有提供 initialValue，或提供了 initialValue 但数组为空，那么回调不会被执行，数组的唯一值将被返回。</li>
</ul>
<p>eg:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 数组求和</span><br><span class="line">let sum = [0, 1, 2, 3].reduce(function (a, b) &#123;</span><br><span class="line">  return a + b;</span><br><span class="line">&#125;, 0);</span><br><span class="line">// 6</span><br><span class="line">// 将二维数组转化为一维 将数组元素展开</span><br><span class="line">let flattened = [[0, 1], [2, 3], [4, 5]].reduce(</span><br><span class="line">  (a, b) =&gt; a.concat(b),</span><br><span class="line">  []</span><br><span class="line">);</span><br><span class="line"> // [0, 1, 2, 3, 4, 5]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="作业："><a href="#作业：" class="headerlink" title="作业："></a>作业：</h2><ul>
<li><code>lv1</code> (必做) : 编写一个函数 <code>factorial(n)</code> 计算 n!<br>举个例子：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">factorial(1) = 1</span><br><span class="line">factorial(2) = 2 * 1 = 2</span><br><span class="line">factorial(3) = 3 * 2 * 1 = 6</span><br><span class="line">factorial(4) = 4 * 3 * 2 * 1 = 24</span><br><span class="line">...</span><br><span class="line">factorial(10) = 10 * 9 * ... * 2 * 1 = 3628800</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>注意用两种方式实现：</p>
<ol>
<li><ol>
<li>循环</li>
<li>递归</li>
</ol>
</li>
</ol>
<p>lv2 (必做)</p>
<p><strong>注意：</strong>只能使用上述数组操作方法完成</p>
<p>封装一个函数将下面这个数组[‘bug1’,1,’bug2’,3,6,2,4,’bug3’]变成[1,2,3,4,5,6]</p>
<p>lv3(必做)</p>
<p><strong>注意：</strong>只能使用上述数组操作方法完成(尽可能用 map,filter,reduce)</p>
<p>以下是一份企业前端员工名单，请你按照下述要求在里面获取你需要的数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">let arr = [</span><br><span class="line">  &#123; id: 1, name: &quot;小邹&quot;, age: 18, sex: &quot;男&quot; &#125;,</span><br><span class="line">  &#123; id: 3, name: &quot;小斯&quot;, age: 56, sex: &quot;女&quot; &#125;,</span><br><span class="line">  &#123; id: 2, name: &quot;小文&quot;, age: 21, sex: &quot;男&quot; &#125;,</span><br><span class="line">  &#123; id: 4, name: &quot;小牛&quot;, age: 22, sex: &quot;女&quot; &#125;,</span><br><span class="line">  &#123; id: 9, name: &quot;大红&quot;, age: 57, sex: &quot;男&quot; &#125;,</span><br><span class="line">  &#123; id: 5, name: &quot;大绿&quot;, age: 44, sex: &quot;女&quot; &#125;,</span><br><span class="line">  &#123; id: 8, name: &quot;大紫&quot;, age: 36, sex: &quot;女&quot; &#125;,</span><br><span class="line">  &#123; id: 7, name: &quot;大黑&quot;, age: 33, sex: &quot;男&quot; &#125;</span><br><span class="line">];</span><br></pre></td></tr></table></figure>

<p>要求 1 新同事小红来了，请你封装一个函数将小红放进名单里并将上述列表变为 id 顺序排列</p>
<p>{ id: 6, name: “小红”, age: 33, sex: “男” }</p>
<p>要求 2 请你封装一个函数，可以计算出名单中所有人的年龄之和为多少</p>
<p>要求 3 公司的“小老板”很好奇公司那些人和他一个姓，请你封装一个函数得到一个新数组里面中所有姓为小的员工的信息</p>
<p>要求 4 老板公司亏钱了，要裁员了，请你封装一个函数将上述名单中年龄大于 35 岁的员工信息删去</p>
</div>
  </article>
  <div class="toc-container">
  <div id="toc" class="toc-article">
    <strong class="toc-title">目录</strong>
    <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#JavaScript-%E5%9F%BA%E7%A1%80"><span class="toc-text">JavaScript 基础</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-JavaScript%EF%BC%9F"><span class="toc-text">什么是 JavaScript？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#JavaScript-%E5%92%8C%E7%94%B1%E6%9D%A5%E5%92%8C%E5%9B%9E%E9%A1%BE"><span class="toc-text">JavaScript 和由来和回顾</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JavaScript-%E7%AE%80%E4%BB%8B"><span class="toc-text">JavaScript 简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0-Function-heavy-check-mark"><span class="toc-text">函数 Function:heavy_check_mark:</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#return"><span class="toc-text">return</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JS-%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E5%92%8C%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-text">JS 执行上下文和作用域</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE-exclamation"><span class="toc-text">作用域链:exclamation:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AB%8B%E5%8D%B3%E6%89%A7%E8%A1%8C%E5%87%BD%E6%95%B0"><span class="toc-text">立即执行函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E5%AD%97-var-amp-amp-let-amp-amp-const-zap"><span class="toc-text">关键字 var&amp;&amp;let&amp;&amp;const:zap:</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#var-%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87"><span class="toc-text">var 变量提升</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#var-%E5%87%BD%E6%95%B0%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C-let-%E5%9D%97%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-text">var 函数作用域和 let 块作用域</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#let-const-%E6%9A%82%E6%97%B6%E6%80%A7%E6%AD%BB%E5%8C%BA"><span class="toc-text">let,const 暂时性死区</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A8%E8%8D%90%E4%BD%BF%E7%94%A8%E5%A3%B0%E6%98%8E%E6%96%B9%E6%B3%95"><span class="toc-text">推荐使用声明方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E-debug"><span class="toc-text">关于 debug</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E4%B8%AD%E7%9A%84-this"><span class="toc-text">函数中的 this</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%BB%98%E8%AE%A4%E7%BB%91%E5%AE%9A"><span class="toc-text">默认绑定</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9A%90%E5%BC%8F%E7%BB%91%E5%AE%9A"><span class="toc-text">隐式绑定</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%98%BE%E5%BC%8F%E7%BB%91%E5%AE%9A"><span class="toc-text">显式绑定</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#call-apply-bind"><span class="toc-text">call,apply,bind</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Array-%E6%95%B0%E7%BB%84"><span class="toc-text">Array 数组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%94%B9%E5%8F%98%E5%8E%9F%E6%95%B0%E7%BB%84%E7%9A%84%E6%96%B9%E6%B3%95-7-%E4%B8%AA"><span class="toc-text">改变原数组的方法(7 个):</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#splice-%E6%B7%BB%E5%8A%A0-%E5%88%A0%E9%99%A4%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0"><span class="toc-text">splice() 添加&#x2F;删除数组元素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#sort-%E6%95%B0%E7%BB%84%E6%8E%92%E5%BA%8F"><span class="toc-text">sort() 数组排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pop-%E5%88%A0%E9%99%A4%E4%B8%80%E4%B8%AA%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%90%8E%E7%9A%84%E4%B8%80%E4%B8%AA%E5%85%83%E7%B4%A0"><span class="toc-text">pop() 删除一个数组中的最后的一个元素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#shift-%E5%88%A0%E9%99%A4%E6%95%B0%E7%BB%84%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%83%E7%B4%A0"><span class="toc-text">shift() 删除数组的第一个元素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#push-%E5%90%91%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%AB%E5%B0%BE%E6%B7%BB%E5%8A%A0%E5%85%83%E7%B4%A0"><span class="toc-text">push() 向数组的末尾添加元素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#unshift"><span class="toc-text">unshift()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#reverse-%E9%A2%A0%E5%80%92%E6%95%B0%E7%BB%84%E4%B8%AD%E5%85%83%E7%B4%A0%E7%9A%84%E9%A1%BA%E5%BA%8F"><span class="toc-text">reverse() 颠倒数组中元素的顺序</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E6%94%B9%E5%8F%98%E5%8E%9F%E6%95%B0%E7%BB%84%E7%9A%84%E6%96%B9%E6%B3%95-8-%E4%B8%AA"><span class="toc-text">不改变原数组的方法(8 个):</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#slice-%E6%B5%85%E6%8B%B7%E8%B4%9D%E6%95%B0%E7%BB%84%E7%9A%84%E5%85%83%E7%B4%A0"><span class="toc-text">slice() 浅拷贝数组的元素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#join-%E6%95%B0%E7%BB%84%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-text">join() 数组转字符串</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#toLocaleString-%E6%95%B0%E7%BB%84%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-text">toLocaleString() 数组转字符串</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#toString-%E6%95%B0%E7%BB%84%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2-%E4%B8%8D%E6%8E%A8%E8%8D%90"><span class="toc-text">toString() 数组转字符串 不推荐</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#cancat"><span class="toc-text">cancat</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#indexOf-%E6%9F%A5%E6%89%BE%E6%95%B0%E7%BB%84%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8%E6%9F%90%E4%B8%AA%E5%85%83%E7%B4%A0%EF%BC%8C%E8%BF%94%E5%9B%9E%E4%B8%8B%E6%A0%87"><span class="toc-text">indexOf() 查找数组是否存在某个元素，返回下标</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#lastIndexOf-%E6%9F%A5%E6%89%BE%E6%8C%87%E5%AE%9A%E5%85%83%E7%B4%A0%E5%9C%A8%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE"><span class="toc-text">lastIndexOf() 查找指定元素在数组中的最后一个位置</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%81%8D%E5%8E%86%E6%96%B9%E6%B3%95-4-%E4%B8%AA"><span class="toc-text">遍历方法(4 个):</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E%E9%81%8D%E5%8E%86%EF%BC%9A"><span class="toc-text">关于遍历：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#forEach"><span class="toc-text">forEach</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#filter-%E8%BF%87%E6%BB%A4%E5%8E%9F%E5%A7%8B%E6%95%B0%E7%BB%84%EF%BC%8C%E8%BF%94%E5%9B%9E%E6%96%B0%E6%95%B0%E7%BB%84"><span class="toc-text">filter 过滤原始数组，返回新数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#map-%E5%AF%B9%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%AF%8F%E4%B8%AA%E5%85%83%E7%B4%A0%E8%BF%9B%E8%A1%8C%E5%A4%84%E7%90%86%EF%BC%8C%E8%BF%94%E5%9B%9E%E6%96%B0%E7%9A%84%E6%95%B0%E7%BB%84"><span class="toc-text">map 对数组中的每个元素进行处理，返回新的数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#reduce-%E4%B8%BA%E6%95%B0%E7%BB%84%E6%8F%90%E4%BE%9B%E7%B4%AF%E5%8A%A0%E5%99%A8%EF%BC%8C%E5%90%88%E5%B9%B6%E4%B8%BA%E4%B8%80%E4%B8%AA%E5%80%BC"><span class="toc-text">reduce 为数组提供累加器，合并为一个值</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%9C%E4%B8%9A%EF%BC%9A"><span class="toc-text">作业：</span></a></li></ol></li></ol>
  </div>

</div>
</div>
<div class="copyright"></div>
 <div class="share" style="width: 100%">
  <!-- <img src="https://kevinofneu-blog-static.oss-cn-beijing.aliyuncs.com/static/2018-12-10-qrcode_for_gh_ffacf5722095_258.jpg" alt="Running Geek" style="margin: auto; display: block;"/>

  <div style="margin: auto; text-align: center; font-size: 0.8em; color: grey;">老铁们关注走一走，不迷路</div> -->
</div>
   
    <div class="post-nav">
      <div class="post-nav-item post-nav-next">
        
          <span>〈 </span>
          <a href="/2021/12/20/index/" rel="next" title="Nginx">
          Nginx
          </a>
        
      </div>
  
      <div class="post-nav-item post-nav-prev">
          
      </div>
    </div>
   
</div>

      
    </div>
    <footer class="footer text-center">
  <div id="bottom-inner">
    <a class="bottom-item" target="_blank" rel="noopener" href="https://Yajoke1024.github.io">首页</a>
    |
    <a
      class="bottom-item"
      href="https://space.bilibili.com/47626233"
      target="_blank"
      >B站</a
    >
    |
    <a class="bottom-item" href="https://github.com/Yajoke1024" target="_blank">GitHub</a> |
    <a
      class="bottom-item"
      href="https://juejin.cn/user/1346228642395912"
      target="_blank"
      >掘金</a
    >
  </div>
</footer>
  <script>
  (function(window, document, undefined) {

    var timer = null;

    function returnTop() {
      cancelAnimationFrame(timer);
      timer = requestAnimationFrame(function fn() {
        var oTop = document.body.scrollTop || document.documentElement.scrollTop;
        if (oTop > 0) {
          document.body.scrollTop = document.documentElement.scrollTop = oTop - 50;
          timer = requestAnimationFrame(fn);
        } else {
          cancelAnimationFrame(timer);
        }
      });
    }

    var hearts = [];
    window.requestAnimationFrame = (function() {
      return window.requestAnimationFrame ||
        window.webkitRequestAnimationFrame ||
        window.mozRequestAnimationFrame ||
        window.oRequestAnimationFrame ||
        window.msRequestAnimationFrame ||
        function(callback) {
          setTimeout(callback, 1000 / 60);
        }
    })();
    init();

    function init() {
      css(".heart{z-index:9999;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);}.heart:after,.heart:before{content: '';width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: absolute;}.heart:after{top: -5px;}.heart:before{left: -5px;}");
      attachEvent();
      gameloop();
      addMenuEvent();
    }

    function gameloop() {
      for (var i = 0; i < hearts.length; i++) {
        if (hearts[i].alpha <= 0) {
          document.body.removeChild(hearts[i].el);
          hearts.splice(i, 1);
          continue;
        }
        hearts[i].y--;
        hearts[i].scale += 0.004;
        hearts[i].alpha -= 0.013;
        hearts[i].el.style.cssText = "left:" + hearts[i].x + "px;top:" + hearts[i].y + "px;opacity:" + hearts[i].alpha + ";transform:scale(" + hearts[i].scale + "," + hearts[i].scale + ") rotate(45deg);background:" + hearts[i].color;
      }
      requestAnimationFrame(gameloop);
    }

    /**
     * 给logo设置点击事件
     * 
     * - 回到顶部
     * - 出现爱心
     */
    function attachEvent() {
      var old = typeof window.onclick === "function" && window.onclick;
      var logo = document.getElementById("logo");
      if (logo) {
        logo.onclick = function(event) {
          returnTop();
          old && old();
          createHeart(event);
        }
      }
      
    }

    function createHeart(event) {
      var d = document.createElement("div");
      d.className = "heart";
      hearts.push({
        el: d,
        x: event.clientX - 5,
        y: event.clientY - 5,
        scale: 1,
        alpha: 1,
        color: randomColor()
      });
      document.body.appendChild(d);
    }

    function css(css) {
      var style = document.createElement("style");
      style.type = "text/css";
      try {
        style.appendChild(document.createTextNode(css));
      } catch (ex) {
        style.styleSheet.cssText = css;
      }
      document.getElementsByTagName('head')[0].appendChild(style);
    }

    function randomColor() {
      // return "rgb(" + (~~(Math.random() * 255)) + "," + (~~(Math.random() * 255)) + "," + (~~(Math.random() * 255)) + ")";
      return "#F44336";
    }

    function addMenuEvent() {
      var menu = document.getElementById('menu-main-post');
      if (menu) {
        var toc = document.getElementById('toc');
        if (toc) {
          menu.onclick = function() {
            if (toc) {
              if (toc.style.display == 'block') {
                toc.style.display = 'none';
              } else {
                toc.style.display = 'block';
              }
            }
          };
        } else {
          menu.style.display = 'none';
        }
      }
    }

  })(window, document);
</script> 

    



  </body>
</html>
